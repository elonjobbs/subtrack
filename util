import { Transaction, parseCSVUniversal, parsePDFText } from './universalParser';

export interface Subscription {
  merchant: string;
  amount: number;
  frequency: 'monthly' | 'annual' | 'quarterly';
  annualCost: number;
  transactions: Transaction[];
  confidence: number;
}

export { Transaction, parseCSVUniversal, parsePDFText };

const KNOWN_SUBSCRIPTIONS = [
  'netflix', 'spotify', 'apple', 'amazon prime', 'amazon music', 'prime video',
  'hulu', 'disney', 'youtube', 'gym', 'fitness', 'planet fitness', 'la fitness',
  'adobe', 'microsoft', 'office 365', 'dropbox', 'google', 'icloud', 'audible',
  'kindle', 'hbo', 'max', 'paramount', 'peacock', 'crunchyroll', 'duolingo',
  'notion', 'slack', 'zoom', 'linkedin', 'canva', 'grammarly', 'nordvpn',
  'expressvpn', 'surfshark', 'chatgpt', 'openai', 'claude', 'anthropic',
  'github', 'heroku', 'aws', 'digitalocean', 'godaddy', 'namecheap',
  'squarespace', 'wix', 'shopify', 'mailchimp', 'constant contact',
  'nytimes', 'wsj', 'washington post', 'medium', 'substack', 'patreon',
  'onlyfans', 'twitch', 'xbox', 'playstation', 'nintendo', 'steam',
  'ea play', 'ubisoft', 'blizzard', 'world of warcraft', 'final fantasy',
  'peloton', 'strava', 'headspace', 'calm', 'noom', 'weight watchers',
  'hello fresh', 'blue apron', 'factor', 'daily harvest', 'instacart',
  'doordash', 'uber eats', 'grubhub', 'dashpass', 'uber one',
  'costco', 'sams club', 'amazon', 'walmart plus', 'target circle',
  'aaa', 'geico', 'progressive', 'state farm', 'allstate',
  'att', 'verizon', 'tmobile', 'sprint', 'comcast', 'xfinity', 'spectrum',
  'sirius', 'siriusxm', 'pandora', 'tidal', 'deezer', 'soundcloud',
  'bumble', 'tinder', 'hinge', 'match', 'eharmony',
  'ancestry', '23andme', 'myheritage',
  'norton', 'mcafee', 'kaspersky', 'bitdefender', 'lastpass', '1password',
  'ring', 'nest', 'adt', 'simplisafe',
];

function normalizeMerchant(merchant: string): string {
  return merchant
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

function isLikelySubscription(merchant: string): boolean {
  const normalized = normalizeMerchant(merchant);
  return KNOWN_SUBSCRIPTIONS.some(sub => normalized.includes(sub));
}

function groupTransactionsByMerchant(transactions: Transaction[]): Map<string, Transaction[]> {
  const groups = new Map<string, Transaction[]>();

  for (const transaction of transactions) {
    const key = normalizeMerchant(transaction.merchant);
    if (!groups.has(key)) {
      groups.set(key, []);
    }
    groups.get(key)!.push(transaction);
  }

  return groups;
}

function detectFrequency(transactions: Transaction[]): {
  frequency: 'monthly' | 'annual' | 'quarterly';
  confidence: number;
} {
  if (transactions.length < 2) {
    return { frequency: 'monthly', confidence: 0.3 };
  }

  const sorted = [...transactions].sort((a, b) => 
    new Date(a.date).getTime() - new Date(b.date).getTime()
  );

  const gaps: number[] = [];
  for (let i = 1; i < sorted.length; i++) {
    const date1 = new Date(sorted[i].date);
    const date2 = new Date(sorted[i - 1].date);
    const days = Math.floor((date1.getTime() - date2.getTime()) / (1000 * 60 * 60 * 24));
    if (days > 0) gaps.push(days);
  }

  if (gaps.length === 0) {
    return { frequency: 'monthly', confidence: 0.3 };
  }

  const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;

  if (avgGap >= 25 && avgGap <= 35) {
    return { frequency: 'monthly', confidence: 0.9 };
  }
  
  if (avgGap >= 80 && avgGap <= 100) {
    return { frequency: 'quarterly', confidence: 0.85 };
  }
  
  if (avgGap >= 340 && avgGap <= 380) {
    return { frequency: 'annual', confidence: 0.85 };
  }

  return { frequency: 'monthly', confidence: 0.4 };
}

export function detectSubscriptions(transactions: Transaction[]): Subscription[] {
  const groups = groupTransactionsByMerchant(transactions);
  const subscriptions: Subscription[] = [];

  for (const [merchantKey, txns] of groups.entries()) {
    // Check if amounts are consistent (subscription-like behavior)
    const amounts = txns.map(t => t.amount);
    const avgAmount = amounts.reduce((a, b) => a + b, 0) / amounts.length;
    
    // Skip very small amounts or very large single purchases
    if (avgAmount < 1 || avgAmount > 500) continue;
    
    // For single transactions, only include if it's a known subscription
    if (txns.length < 2) {
      if (isLikelySubscription(merchantKey)) {
        subscriptions.push({
          merchant: txns[0].merchant,
          amount: avgAmount,
          frequency: 'monthly',
          annualCost: avgAmount * 12,
          transactions: txns,
          confidence: 0.5
        });
      }
      continue;
    }

    const { frequency, confidence } = detectFrequency(txns);
    
    // Check amount consistency
    const maxDeviation = Math.max(...amounts.map(a => Math.abs(a - avgAmount)));
    
    // If amounts vary too much (>20%), probably not a subscription
    if (maxDeviation > avgAmount * 0.2) continue;

    let finalConfidence = confidence;
    if (isLikelySubscription(merchantKey)) {
      finalConfidence = Math.min(0.95, confidence + 0.2);
    }

    // Only include if we have some confidence
    if (finalConfidence < 0.3) continue;

    subscriptions.push({
      merchant: txns[0].merchant,
      amount: avgAmount,
      frequency,
      annualCost: frequency === 'monthly' ? avgAmount * 12 :
                 frequency === 'quarterly' ? avgAmount * 4 :
                 avgAmount,
      transactions: txns,
      confidence: finalConfidence
    });
  }

  return subscriptions.sort((a, b) => b.annualCost - a.annualCost);
}

export function calculateTotalAnnualCost(subscriptions: Subscription[]): number {
  return subscriptions.reduce((sum, sub) => sum + sub.annualCost, 0);
}
